---
title: "Main"
author: "Wendy Shi"
date: "2023-11-22"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r}
# load in libraries
package_list <- c("tidyverse", "vroom", "dplyr", "patchwork")

# load in packages
for (package_name in package_list) {
  if (!requireNamespace(package_name, quietly = TRUE)) {
    install.packages(package_name)
  }
  library(package_name, character.only = TRUE)
}

# load in data
df <- vroom("ddh.csv")
head(df)
```

```{r Figure 1, fig.cap="Boxplots of time-weighted average of donor glucose measurements, donor glucose range, and donor glucose standard deviation for 427 recipients experiencing initial graft function (IGF in white) and for 145 recipients experiencing liver graft dysfunction (LGD, in gray)."}

# faceted by IGF and LGD (initial graft function and liver graft dysfunction)
# Identified by variable "delayed_fn", "1" = yes.
# Ploted vertically on a logrithmic scale



twa<-ggplot(df, aes(x = factor(delayed_fn), y = glutwa, fill = factor(delayed_fn))) +
  
  # error bars function to create horizontal lines at ends of whiskers
  stat_boxplot(geom ='errorbar', coef = Inf, size = 0.2) + 
  
  # overlaying the boxplots over the error bars, extending whiskers with coef = Inf
  geom_boxplot(coef = Inf, size = 0.2) +
  
  # manually setting scale breaks and limits
  scale_y_continuous(limits=c(50, 500),
                     breaks=c(50, 100, 200, 300, 400, 500),
  
  # putting in log scale
                     trans='log10') + 
  
  # coloring gray and white
  scale_fill_manual(values=c("0"="white", "1"="gray")) +
  
  # labeling IGF vs LGD
  scale_x_discrete(labels=c("0"="IGF", "1"="LGD")) +
  
  # labelinga and getting rid of legend
  labs(title="", x= "TWA", y="") +
  theme(legend.position="none")
    

range <- ggplot(df, aes(x = factor(delayed_fn), y=glurange, fill=factor(delayed_fn))) +
  stat_boxplot(geom ='errorbar', coef = Inf, size = 0.2) + 
  geom_boxplot(coef = Inf, size = 0.2) +
  scale_y_continuous(limits=c(1, 1000), 
                     breaks=c(1, 10, 100, 1000),
                     trans='log10') + 
  scale_fill_manual(values=c("0"="white", "1"="gray")) +
  scale_x_discrete(labels=c("0"="IGF", "1"="LGD")) +
  labs(title="", x= "Range", y="") +
  theme(legend.position="none")
    
sd <- ggplot(df, aes(x = factor(delayed_fn), y=glusd, fill=factor(delayed_fn))) +
  stat_boxplot(geom ='errorbar', coef = Inf, size = 0.2) + 
  geom_boxplot(coef = Inf, size = 0.2) + 
  scale_y_continuous(limits=c(1, 300), 
                     breaks=c(1, 10, 100, 200, 300),
                     trans='log10') + 
    scale_fill_manual(values=c("0"="white", "1"="gray")) +
    scale_x_discrete(labels=c("0"="IGF", "1"="LGD")) +
    labs(title="", x= "SD", y="")+
    theme(legend.position="none")


twa + range + sd + plot_annotation(title = "Donor Glucose Measures mg/dl")
```
```{r}
# create a multivariable logistic regression model where the response is liver graft function "delayed_fn"
# interested predictor variable is twa of donor glucose measurements "glutwa".
# controling for other predictors such as age, cause of death, calculated model for end stage liver disease score, and hemodynamic instability "d_age", "d_cod", "r_meld_calc", "hemo_instability"

model <- glm(delayed_fn ~ log(glutwa), data = df, family = "binomial")

model_a <- glm(delayed_fn ~ log(glutwa) + d_age + as.factor(d_cod) + 
                 hemo_instability , data = df, family = "binomial")

```



```{r}


coefficients <- coef(model)
standard_errors <- summary(model)$coefficients[, "Std. Error"]

# Calculate the variance of log-relative_doubling_odds_ratio using the delta method
var <- (log(2))^2 * standard_errors["log(glutwa)"]^2

# Calculate the standard error of the coefficient
std_err <- sqrt(var)

# getting the raw coefficient
coef_logTWA <- coefficients["log(glutwa)"]

# getting the coefficient for interpretation associated with doubling of TWA
coef_estimate <- exp(coef_logTWA*log(2))

# creating confidence interval estimates associated with this coefficient
lower_CI <- coef_estimate * exp(-1.96 * std_err["log(glutwa)"])
upper_CI <- coef_estimate * exp(1.96 * std_err["log(glutwa)"])



# Conducting the Wald Z test
wald_z <- coef_logTWA / standard_errors["log(glutwa)"]

# Calculate p-values
p_value <- 2 * (1 - pnorm(abs(wald_z)))


# print out values
print(paste0("Odds ratio and 95% CI in primary exposure model (TWA) is: ",
            round(coef_estimate[["log(glutwa)"]], 2), 
            " (", round(lower_CI[["log(glutwa)"]], 2), ", ",
            round(upper_CI[["log(glutwa)"]], 2),")" ))

print(paste0("The p value is: ",
             round(p_value[["log(glutwa)"]], 2)))

# they are doing a profile likelihood instead of a wald test
```

```{r}
# same things for adjusted model
coefficients_a <- coef(model_a)
standard_errors_a <- summary(model_a)$coefficients[, "Std. Error"]
var_a <- (log(2))^2 * standard_errors_a["log(glutwa)"]^2
std_err_a <- sqrt(var_a)
coef_logTWA_a <- coefficients_a["log(glutwa)"]
coef_estimate_a <- exp(coef_logTWA_a*log(2))
lower_CI_a <- coef_estimate_a * exp(-1.96 * std_err_a["log(glutwa)"])
upper_CI_a <- coef_estimate_a * exp(1.96 * std_err_a["log(glutwa)"])

# Conducting the Wald Z test
wald_z_a <- coef_logTWA_a / standard_errors_a["log(glutwa)"]
p_value_a <- 2 * (1 - pnorm(abs(wald_z_a)))

coef_estimate_a
lower_CI_a
upper_CI_a
p_value_a
```

